---
title: "STA 650 HW 3"
author: "Leonardo Shu"
date: "March 2, 2017"
output: pdf_document
---

K-means
fast greedy = hier clust
lev
spectral
SBM
SBMMM
spectral cov

2738
239
11364
18005
18543
24758
17951
8239
26321
2895

8100

Packages:
```{r, warning = FALSE, comment = FALSE, message = FALSE, echo = FALSE, size = "small"}
set.seed(101)
#set.seed(107)

library(igraph)
library(igraphdata)
library(xtable)
library(network)
library(ergm)
library(hergm)
library(Matrix)
library(networkD3)
library(magrittr)
library(MCL)
library(mixedMem)
library(CIDnetworks)
library(data.table)
library(stringr)
library(readr)
library(sand)
library(sna)
library(ape)
library(mixer)
library(eigenmodel)
library(blockmodels)
library(lda)
library(plyr)
library(SpecClustPack)

edj2895 = getEdgesK("2895.egonet")
circles2895= getCircles("2895.circles")
graph2895 = getGraph(edj2895)
adj2895 = getAdjacency(graph2895)
nodes2895 = getNodes(adj2895)
dim(adj2895)
plot(graph2895)

edj8100 = getEdgesK("8100.egonet")
circles8100= getCircles("8100.circles")
graph8100 = getGraph(edj8100)
adj8100 = getAdjacency(graph8100)
nodes8100 = getNodes(adj8100)
dim(adj8100)
plot(graph8100)
```

GETTING FEATURES
```{r}
library(readr)
library(stringr)
library(dplyr)
features = read_lines("features.txt")
featureList = read_lines("featureList.txt")
featList = paste0("[0-9]+\\s", featureList)
head(features)
testFeat = features[[1]]
extractValue = function(node, feat){
  sapply(feat, str_extract, string = node) %>%
    str_extract(pattern = "[0-9]+")
}
extractValue(testFeat, featList)
resMat = lapply(features, extractValue, feat = featList) %>% do.call(rbind, .)
featuresTable = apply(resMat, 2, as.numeric)
colnames(featuresTable) = featureList
dim(featuresTable)
write.csv2(featuresTable, file = "featuresTable.csv")
```



Loading the data:
```{r}
#getEdges = function(graphFile){
#  graphEdgesK = read.csv(
#  file = graphFile,
#  sep=" ", header=F,
#  col.names=c("source", "target"))
#  
#  return(graphEdgesK)
#}

getCircles = function(circlesFile){
  
  # Read in the data
  x = scan(circlesFile, what="", sep="\n")
  # Separate elements by one or more whitepace
  y = strsplit(x, "[[:space:]]+")
  # Extract the first vector element and set it as the list element name
  names(y) = sapply(y, `[[`, 1)
  # Remove the first vector element from each list element
  y = lapply(y, `[`, -1)
  # Change character to numbers
  y = sapply(y, as.numeric)
  
  circles0Names = names(y)
  circles0 = y
  
  for(i in 1:length(y)){
    circles0[[i]] = t(as.matrix(y[[i]]))
  }
  
  circles0 = rbind.fill.matrix(circles0)
  rownames(circles0) = circles0Names
  
  return(circles0)
}

getCirclesEst = function(circlesEst){
  
  #circles0Names = names(y)
  y = circlesEst
  circles0 = y
  
  for(i in 1:length(y)){
    circles0[[i]] = t(as.matrix(y[[i]]))
  }
  
  circles0 = rbind.fill.matrix(circles0)
  #rownames(circles0) = circles0Names
  
  return(circles0)
}

# Edgelist for Kaggle #
getEdgesK = function(edgeFile){
  graphKEdges = getCircles(edgeFile)
  nodeN = as.numeric(str_replace(rownames(graphKEdges), pattern =  ":", replacement = ""))
  rownames(graphKEdges) = c()
  indexNA = c()
  for(i in 1:dim(graphKEdges)[1]){
    if(is.na(graphKEdges[i,1])){
      indexNA = c(indexNA, i)
    } 
  }
  graphKEdges = graphKEdges[-indexNA,]
  nodeN = nodeN[-indexNA]
  
  edgeListK = as.data.frame(matrix(0,1,2))
  colnames(edgeListK) = c("Source", "Target")
  for(i in 1:dim(graphKEdges)[1]){
    for(j in 1:dim(graphKEdges)[2]){
      newEdge = c(nodeN[i], graphKEdges[i,j])
      edgeListK = rbind(edgeListK, newEdge)
    }
  }
  edgeListK = edgeListK[-1,]
  edgeListK = edgeListK[ !is.na(apply(edgeListK ,1,mean)) ,]
  edgeListK = unique(t(as.matrix(apply(edgeListK, 1, sort))))

  edjK = as.matrix(edgeListK)
  rownames(edjK) = c()
  
  return(edjK)
} 

getGraph = function(edjK){
  temp = apply(edjK,1,as.character)
  temp = t(temp)
  graphK = graph_from_edgelist(temp, directed = FALSE)
  return(graphK)
}

#Need to remove missing#

fixMissing = function(edjK, missingN){
  indexFix = c()
    for(i in 1:dim(edjK)[1]){
      for(j in 1:length(missingN)){
        if(missingN[j] %in% edjK[i,]){
          indexFix = c(indexFix, i)
        }
      }
    } 
  return(indexFix)
}

getTrueCircles = function(graphNodesK, circlesK){
  truthK = c()
  for(i in 1:length(graphNodesK$id)){
    for(j in 1:dim(circlesK)[1]){
      if(graphNodesK$id[i] %in% circlesK[j,]){
        truthK[i] = j  
      }
    }
  }
  return(truthK)
}

#length(getTrueCircles(graphNodes239, graph239Circles))
#length(getTrueCircles(nodes345, circles345))

getMissingNodes = function(grapNodesK, truthK){
  missingNodes = graphNodesK$id[which(is.na(truthK))]
  return(missingNodes)
}

fixCircles = function(truthK){
  truthKFix = truthK[-which(is.na(truthK))]
  return(truthKFix)
}


fixEdges = function(edjK, circlesK, graphNodesK, missingNodes){
  index = fixMissing(edjK, missingNodes)
  edjKFix = edjK[-index,]
  return(edjKFix)
}

# Get adjacency #
getAdjacency = function(graphK){
  adjK = as.matrix(get.adjacency(graphK))
  return(adjK)
}

#adj239 = as.matrix(get.adjacency(graph239))

# Graph Nodes #
getNodes = function(adjK){
  graphNodesK <- data.frame(
  id=as.integer(rownames(adjK)))
  graphNodesK$group <- 1
  #dim(graphNodesK)
  return(graphNodesK)
}

clustersToCircles = function(memK){
  y = memK
  circlesEstK = list()
  
  for(i in 1:length(y)){
    circlesEstK[[i]] = t(as.matrix(y[[i]]))
  }
  
  circlesEstK = rbind.fill.matrix(circlesEstK)
  
  return(circlesEstK)
}

# FAST GREEDY #
fastGreedyClust = function(graphK, centersK){
  kc = fastgreedy.community(graphK)
  
  if(centersK != 0){
    kc2 = cut_at(kc, centersK)
    kc = make_clusters(graphK, membership = kc2)
  }
  
  #membership(kc)
  plot(kc, graphK, main ="Fast & Greedy")
  return(kc)
}

# LEADING EV #
levClust = function(graphK){
  lev = leading.eigenvector.community(graphK)
  #lev = make_clusters(graphK, membership = lev$membership)
  plot(lev, graphK, main ="LEV")
  return(lev)
}

# Spectral Clustering #
clusterSpec = function(graphK, graphNodesK, adjK, blocksK){
  # Spectral Clustering #
  SCVecK = specClust(adjMat = adjK, nBlocks = blocksK, nIter = 1000)
  #clusterK = kmeans(adjK, centers = centersK)
  graphNodesK$group = SCVecK
  
  # Checking the clusters #
  clusterID = SCVecK
  nodesID = graphNodesK$id
  
  clusterList = list()

  for(i in 1:length(unique(clusterID))){
    clusterList[[i]] = graphNodesK$id[which(graphNodesK$group == unique(clusterID)[i])]
  }
  
  circlesKEstSC = getCirclesEst(clusterList)
  
  clustKSC = as_membership(SCVecK)
  
  communitiesSC = make_clusters(graphK, membership = clustKSC)
  
  plot(communitiesSC, graphK, main ="Spectral Clustering") 
  
  return(circlesKEstSC)
  
}

# SBM #
clusterSBM = function(graphK, graphNodesK, adjK, centersK){
  
  #SBM#
  sbmK = mixer(as.matrix(adjK), qmin = 1, qmax = centersK+1)
  sbmKOutput = getModel(sbmK)
  
  clusterLabels = c()
  for(i in 1:dim(sbmKOutput$Taus)[2]){
    clusterLabels[i] = which.max(sbmKOutput$Taus[,i])
  }
  
  graphNodesK$group = clusterLabels
  
  # Checking the clusters #
  clusterID = clusterLabels
  nodesID = graphNodesK$id
  
  clusterList = list()

  for(i in 1:length(unique(clusterID))){
    clusterList[[i]] = graphNodesK$id[which(graphNodesK$group == unique(clusterID)[i])]
  }
  
  circlesKEstK = getCirclesEst(clusterList)
  
  clustSBM = as_membership(clusterLabels)
  
  communitiesSBM = make_clusters(graphK, membership = clustSBM)
  
  plot(communitiesSBM, graphK, main ="SBM")
  plot(sbmK)
  
  return(circlesKEstK)
  
}

# K Means #
clusterK = function(graphK, graphNodesK, adjK, centersK){
  #K-Means#
  clusterK = kmeans(adjK, centers = centersK)
  graphNodesK$group = clusterK$cluster
  
  # Checking the clusters #
  clusterID = clusterK$cluster
  nodesID = graphNodesK$id
  
  clusterList = list()

  for(i in 1:length(unique(clusterID))){
    clusterList[[i]] = graphNodesK$id[which(graphNodesK$group == unique(clusterID)[i])]
  }
  
  circlesKEstK = getCirclesEst(clusterList)
  
  clustKmeans = as_membership(clusterK$cluster)
  
  communitiesKMeans = make_clusters(graphK, membership = clustKmeans)
  
  plot(communitiesKMeans, graphK, main ="K-Means") 
  
  return(circlesKEstK)
  
}

# MCL #
clusterMCL = function(graphK, nodesK, adjK){
  cluster <- mcl(
    x = adjK, addLoops=TRUE, ESM = TRUE)
  nodesK$group = cluster$Cluster
  clusterID1 = as.integer(nodesK$group)
  clusterList1 = list()
  
  for(i in 1:length(unique(clusterID1))){
    clusterList1[[i]] = nodesK$id[which(nodesK$group == unique(clusterID1)[i])]
  }
  
  circlesKEstMCL = getCirclesEst(clusterList1)

  clustKMCL = as_membership(cluster$Cluster)

  communitiesKMCL = make_clusters(graphK, membership = clustKMCL)

  plot(communitiesKMCL, graphK, main ="Markov Clustering")
  
  return(circlesKEstMCL)
}
```

Full Example with 239:
```{r}
# Setting #
edj239 = getEdgesK("239.egonet")
circles239= getCircles("239.circles")
graph239 = getGraph(edj239)
adj239 = getAdjacency(graph239)
nodes239 = getNodes(adj239)
dim(adj239)
plot(graph239)

trueCircles239 = dim(circles239)[1]

# Clustering #
kEst239 = clusterK(graph239, nodes239, adj239, trueCircles239)
fgEst239 = fastGreedyClust(graph239, trueCircles239)
levEst239 = levClust(graph239)
mclEST239 = clusterMCL(graph239, nodes239, adj239)
sbmEst239 = clusterSBM(graph239, nodes239, adj239, trueCircles239)
specEst239 = clusterSpec(graph239, nodes239, adj239, trueCircles239)
```



Kaggle Data:
```{r}
library(readr)
library(stringr)
library(dplyr)
features = read_lines("features.txt")
featureList = read_lines("featureList.txt")
featList = paste0("[0-9]+\\s", featureList)
head(features)
testFeat = features[[1]]
extractValue = function(node, feat){
  sapply(feat, str_extract, string = node) %>%
    str_extract(pattern = "[0-9]+")
}
extractValue(testFeat, featList)
resMat = lapply(features, extractValue, feat = featList) %>% do.call(rbind, .)
featuresTable = apply(resMat, 2, as.numeric)
colnames(featuresTable) = featureList
dim(featuresTable)
write.csv2(featuresTable, file = "featuresTable.csv")


# Reading Data #
#graph239Circles = read.csv(
#  file = '239.circles',
#  sep=" ", header=F)
#graph239Circles = graph239Circles[,-1]

#getCircles = function(graphFile){
#  graphKCircles = read.csv(
#  file = graphFile,
#  sep=" ", header=F)
#  graphKCircles = graphKCircles[,-1]
#  return(graphKCircles)
#}

#graph239Circles = getCircles('239.circles')


# Get membership vector for circles #
# Make truth into vector #
truth239 = c()
for(i in 1:length(graphNodes239$id)){
  for(j in 1:dim(graph239Circles)[1]){
    if(graphNodes239$id[i] %in% graph239Circles[j,]){
      truth239[i] = j  
    }
  }
}
missingNodes = graphNodes239$id[which(is.na(truth239))]
truth239 = truth239[-which(is.na(truth239))]

# Formatting to get EdgeList Format #
# Get node list #
getEdges = function(graphFile){
  graphKEdges = read.csv(
  file = graphFile,
  sep=" ", header=F)
  
  nodeN = as.character(graphKEdges[,1])
  nodeN = unlist(strsplit(nodeN, ":"))
  nodeN = as.numeric(nodeN)
  graphKEdges = graphKEdges[,-1]
  
  edgeListK = as.data.frame(matrix(0,1,2))
  colnames(edgeListK) = c("Source", "Target")
  for(i in 1:dim(graphKEdges)[1]){
    for(j in 1:dim(graphKEdges)[2]){
      newEdge = c(nodeN[i], graphKEdges[i,j])
      edgeListK = rbind(edgeListK, newEdge)
    }
  }
  edgeListK = edgeListK[-1,]
  edgeListK <- edgeListK[ !is.na(apply(edgeListK, 1, mean)) ,]
  edgeListK = unique(t(as.matrix(apply(edgeListK, 1, sort))))
  
  edjK = as.matrix(edgeListK)
  rownames(edjK) = c()
  
  return(edjK)
}

# Make graph #

getGraph = function(edjK){
  temp = apply(edjK,1,as.character)
  temp = t(temp)
  graphK = graph_from_edgelist(temp, directed = FALSE)
  return(graphK)
}



######

graph239Edges = read.csv(
  file = '239.egonet',
  sep=" ", header=F)

nodeN = as.character(graph239Edges[,1])
nodeN = unlist(strsplit(nodeN, ":"))
nodeN = as.numeric(nodeN)
graph239Edges = graph239Edges[,-1]

edgeList239 = as.data.frame(matrix(0,1,2))
colnames(edgeList239) = c("Source", "Target")
for(i in 1:dim(graph239Edges)[1]){
  for(j in 1:dim(graph239Edges)[2]){
    newEdge = c(nodeN[i], graph239Edges[i,j])
    edgeList239 = rbind(edgeList239, newEdge)
  }
}
edgeList239 = edgeList239[-1,]
edgeList239 <- edgeList239[ !is.na(apply(edgeList239 ,1,mean)) ,]
edgeList239 = unique(t(as.matrix(apply(edgeList239, 1, sort))))

edj239 = as.matrix(edgeList239)
rownames(edj239) = c()
###########


getTrueCircles = function(graphNodesK, circlesK){
  truthK = c()
  for(i in 1:length(graphNodesK$id)){
    for(j in 1:dim(circlesK)[1]){
      if(graphNodesK$id[i] %in% circlesK[j,]){
        truthK[i] = j  
      }
    }
  }
  return(truthK)
}

length(getTrueCircles(graphNodes239, graph239Circles))
length(getTrueCircles(nodes345, circles345))

getMissingNodes = function(grapNodesK, truthK){
  missingNodes = graphNodesK$id[which(is.na(truthK))]
  return(missingNodes)
}

fixCircles = function(truthK){
  truthKFix = truthK[-which(is.na(truthK))]
  return(truthKFix)
}


fixEdges = function(edjK, circlesK, graphNodesK, missingNodes){
  index = fixMissing(edjK, missingNodes)
  edjKFix = edjK[-index,]
  return(edjKFix)
}

#getGraph = function(edjK){
#  temp = apply(edjK,1,as.character)
#  temp = t(temp)
#  graphK = graph_from_edgelist(temp, directed = FALSE)
#  return(graphK)
#}

#edj239 = edj239[-index,]
#temp = apply(edj239,1,as.character)
#temp = t(temp)
#graph239 = graph_from_edgelist(temp, directed = FALSE)

# Get adjacency #
getAdjacency = function(graphK){
  adjK = as.matrix(get.adjacency(graphK))
  return(adjK)
}

#adj239 = as.matrix(get.adjacency(graph239))

# Graph Nodes #
getNodes = function(adjK){
  graphNodesK <- data.frame(
  id=as.integer(rownames(adjK)))
  graphNodesK$group <- 1
  #dim(graphNodesK)
  return(graphNodesK)
}

#graphNodes239 <- data.frame(
#  id=as.integer(rownames(adj239)))
#graphNodes239$group <- 1
#dim(graphNodes239)

#plot(graph239,layout=layout_nicely(graph239))
```

Finding duplicates:
```{r}
getDuplicates = function(circles0){
  for(i in 1:nrow(circles0)){
    print(circles0[i, which(circles0[i,] != is.na(circles0[i,]))])
  }
  
  #circles0 = getCircles("0.circles")
  table(circles0[1,])
  c0List = c(circles0)
  c0List = c0List[which(c0List != is.na(c0List))]
  length(unique(c0List))
  table(c0List)
  c0Multiple = as.matrix(table(c0List)[which(table(c0List) > 1)])
  multipleNodes = as.numeric(rownames(c0Multiple))
  
  return(multipleNodes)
  
}

duplicates0 = getDuplicates(circles0)
duplicates0 
  
duplicates239 = getDuplicates(graph239Circles)
duplicates239
```

TEST WITH 239:
```{r}
edj239 = getEdgesK("239.egonet")
circles239= getCircles("239.circles")
graph239 = getGraph(edj239)
adj239 = getAdjacency(graph239)
nodes239 = getNodes(adj239)
dim(adj239)
plot(graph239)
```




TEST WITH 345:
```{r}
edj345 = getEdgesK("345.egonet")
circles345= getCircles("345.circles")
graph345 = getGraph(edj345)
adj345 = getAdjacency(graph345)
nodes345 = getNodes(adj345)
dim(adj345)
truth345 = getTrueCircles(nodes345, circles345)
########
clusterMCL = function(graphK, nodesK, adjK){
  cluster <- mcl(
    x = adjK, addLoops=TRUE, ESM = TRUE)
  nodesK$group = cluster$Cluster
  clusterID1 = as.integer(nodesK$group)
  clusterList1 = list()
  
  for(i in 1:length(unique(clusterID1))){
    clusterList1[[i]] = nodesK$id[which(nodesK$group == unique(clusterID1)[i])]
  }
  
  circlesKEstMCL = getCirclesEst(clusterList1)

  clustKMCL = as_membership(cluster$Cluster)

  communitiesKMCL = make_clusters(graphK, membership = clustKMCL)

  plot(communitiesKMCL, graphK)
  
  return(circlesKEstMCL)
}

mclEST239 = clusterMCL(graph239, nodes239, adj239)

############

clusterK = function(graphK, graphNodesK, adjK, centersK){
  #K-Means#
  clusterK = kmeans(adjK, centers = centersK)
  graphNodesK$group = clusterK$cluster
  
  # Checking the clusters #
  clusterID = clusterK$cluster
  nodesID = graphNodesK$id
  
  clusterList = list()

  for(i in 1:length(unique(clusterID))){
    clusterList[[i]] = graphNodesK$id[which(graphNodesK$group == unique(clusterID)[i])]
  }
  
  circlesKEstK = getCirclesEst(clusterList)
  
  clustKmeans = as_membership(clusterK$cluster)
  
  communitiesKMeans = make_clusters(graphK, membership = clustKmeans)
  
  plot(communitiesKMeans, graphK) 
  
  return(circlesKEstK)
  
}

kEst239 = clusterK(graph239, nodes239, adj239, 4)

#nodesCircles = c()
#nodesCirclesMem = c()
#for(i in 1:dim(circles345)[1]){
#  nodesCircles = c(nodesCircles, circles345[i,])
#  nodesCirclesMem = c(nodesCirclesMem, rep(i, length(which(!is.na(circles345[i,])))))
#}
#nodesCircles =  nodesCircles[which(!is.na(nodesCircles))]
#length(nodesCirclesMem)
#nodesCirclesMem
#indexDupli = which(duplicated(nodesCircles))
#nodesCircles = nodesCircles[-indexDupli]
#nodesCirclesMem = nodesCirclesMem[-indexDupli]
#length(unique(nodesCircles))

#length(!is.na(circles345[1,]))

edj2895 = getEdgesK("2895.egonet")
circles2895= getCircles("2895.circles")
graph2895 = getGraph(edj2895)
adj2895 = getAdjacency(graph2895)
nodes2895 = getNodes(adj2895)
dim(adj2895)
plot(graph2895)

edj1357 = getEdgesK("1357.egonet")
circles1357= getCircles("1357.circles")
graph1357 = getGraph(edj1357)
adj1357 = getAdjacency(graph1357)
nodes1357 = getNodes(adj1357)
dim(adj1357)
plot(graph1357)

kEst345 = clusterK(graph345, nodes345, adj345, 7)
kEst611 = clusterK(graph611, nodes611, adj611, 10)

```



Getting the graph objects:
```{r}
#graph.edges <- read.csv(
#  file = '0.edges',
#  sep=" ", header=F,
#  col.names=c("source", "target"))

#graph.edges <- graph.edges - min(graph.edges) + 1
#graph.nodes <- data.frame(
#  id=seq(max(graph.edges) - min(graph.edges) + 1))
#graph.nodes$group <- 1
#graph.edges <- graphEdges - min(graphEdges) + 1

edj0 = as.matrix(graphEdges0)
temp = apply(edj0,1,as.character)
temp = t(temp)
graph0 = graph_from_edgelist(temp, directed = FALSE)

# Get adjacency #
#adj0 = as.matrix(get.adjacency(graph0))
adj0 = as.matrix(get.adjacency(graph0)/2)
graph0 = as.undirected(graph_from_adjacency_matrix(adj0))
plot(graph0,layout=layout_nicely(graph0))

# ergm #
HK1 = fit_hrg(K1)
HK1$vertices
HKTree = hrg_tree(HK1)
HKTree
plot(HKTree)
plot_dendrogram(HK1)

# hergm #
K2 = network(as.matrix(graphEdges), directed = FALSE)
HK2 = ergm(K2 ~ edges)
summary(HK2)
```

```{r}
# Node degrees
# 'degree' has a mode of 'in' for in-degree, 'out' for out-degree,
# and 'all' or 'total' for total degree. 
deg <- degree(graph0)
deg
hist(deg,  main="Histogram of node degree")

degC = centr_degree(graph0, normalized=T)
hist(degC$res)

centr_clo(graph0, mode="all", normalized=T) 

centr_eigen(graph0, directed=T, normalized=T) 

#betweenness(KADJ)
#edge_betweenness(K1)
centr_betw(graph0)

install.packages("amen")
library(amen)
data("dutchcollege")
plot(dutchcollege)
names(dutchcollege)
View(dutchcollege$Y)
```

Clustering:
```{r}
##############
graphNodes239 <- data.frame(
  id=as.integer(rownames(adj239)))
graphNodes239$group <- 1
dim(graphNodes239)

#network <- forceNetwork(
#  Links = graph.edges - 1, Nodes = graph.nodes,
#  Source = "source", Target = "target",
#  NodeID = "id",
#  Group = "group", opacity = 0.8)
#network %>% saveNetwork(file = 'Net1.html')
#print(network)

graph.cluster <- function(adjacency){
  #n <- nrow(nodes)
  #adjacency <- matrix(0, n, n)
  #index <- cbind(
  #  edges$source, edges$target)
  #adjacency[index] <- 1
  
  cluster <- mcl(
    x = adjacency, addLoops=TRUE, ESM = TRUE)
  #print(cluster$Cluster)
  cluster$Cluster
}

colnames(edj239) = c("source", "target")
edj239 = as.data.frame(edj239)
# Assigning the clusters calculated #
graphNodes239$group <- graph.cluster(adj239)

# Checking the clusters #
clusterID1 = as.integer(graphNodes239$group)
clusterList1 = list()

for(i in 1:length(unique(clusterID1))){
  clusterList1[[i]] = graphNodes239$id[which(graphNodes239$group == unique(clusterID1)[i])]
}

circles239EstMCL = getCirclesEst(clusterList1)

clust239MCL = as_membership(graph.cluster(adj239))

communities239MCL = make_clusters(graph239, membership = clust239MCL)

plot(communities239MCL, graph239)


## IMPORTANT ##

#K-Means#
cluster239 = kmeans(adj239, centers = 4)
graphNodes239$group = cluster239$cluster

# Checking the clusters #
clusterID = cluster239$cluster
nodesID = graphNodes239$id

clusterList = list()

for(i in 1:length(unique(clusterID))){
  clusterList[[i]] = graphNodes239$id[which(graphNodes239$group == unique(clusterID)[i])]
}

circles239EstK = getCirclesEst(clusterList)

clust239Kmeans = as_membership(cluster239$cluster)

communities239KMeans = make_clusters(graph239, membership = clust239Kmeans)

plot(communities239KMeans, graph239)


#network.cluster <- forceNetwork(
#  Links = graph.edges - 1, Nodes = graph.nodes,
#  Source = "source", Target = "target",
#  NodeID = "id",
#  Group = "group", opacity = 0.8)
#network.cluster %>% saveNetwork(file = 'Net2.html')

#print(network.cluster)
```

```{r}
#################
###############

# FAST GREEDY #
fastGreedyClust = function(graphK, centersK){
  kc = fastgreedy.community(graphK)
  
  if(centersK != 0){
    kc2 = cut_at(kc, centersK)
    kc = make_clusters(graphK, membership = kc2)
  }
  
  #membership(kc)
  #plot(kc, graphK)
  return(kc)
}

kc239 = fastGreedyClust(graph239, 4)
plot(kc239, graph239)
FGCEst239 = clustersToCircles(kc239)

kc345 = fastGreedyClust(graph345, 0)
plot(kc345, graph345)
FGCEst345 = clustersToCircles(kc345)



#kc = fastgreedy.community(graph345)
#kc2 = cut_at(kc, 4)
#kc = make_clusters(graph239, membership = kc2)
#membership(kc)
#plot(kc, graph345)
#View(adj239)

# LEADING EV #
levClust = function(graphK){
  lev = leading.eigenvector.community(graphK)
  #lev = make_clusters(graphK, membership = lev$membership)
  return(lev)
}
lev239 = levClust(graph239)
plot(lev239, graph239)
levEst239 = clustersToCircles(lev239)

lev345 = levClust(graph345)
plot(lev345, graph345)
levEst345 = clustersToCircles(lev345)


#lev = leading.eigenvector.community(graph239)
#lev2 = cut_at(lev, 4)
#lev = make_clusters(graph239, membership = lev2)
#membership(lev)
#plot(lev, graph239)



```

COMPARING CLUSTERS:
```{r}
library(fpc)

graphNodes0$id 


# Make truth into vector #
truth239 = c()
for(i in 1:length(graphNodes239$id)){
  for(j in 1:dim(graph239Circles)[1]){
    if(graphNodes239$id[i] %in% graph239Circles[j,]){
      truth239[i] = j  
    }
  }
}
missingNodes = graphNodes239$id[which(is.na(truth239))]
truth239 = truth239[-which(is.na(truth239))]

length(truth239)

for(i in 1:24){
  #print(graphNodes0$id[6] %in% circles0[i,])
  print(which(circles0[i,] == graphNodes0$id[6]))
}

for(i in 1:2){
  print(graphNodes0$id[6] %in% graphEdges0[,i])
}

which(graph239Circles[4,] == graphNodes239$id[98])

est1 = cluster239$cluster

truth239
est1 = unname(est1)

k = dist(adj239)

#RAND between 0 and 1#
clusterDist = cluster.stats(k, clustering = as.vector(truth239), alt.clustering = as.vector(cluster239$cluster))
clusterDist
```





```{r, eval = FALSE}
mmsbGibbs0 = mmsb.collapsed.gibbs.sampler(adj0, 20, num.iterations = 1000, alpha = 1, beta.prior = list(diag(1,20,20),diag(1,20,20)))
```

CID
```{r}
###DATA EXPLORATION

###  Let's look at the structure of the Sampson Monastery data.
load("sampson.RData")
monk = Sampson
###  Let's build a CID object
friendObject <- CID(as.sociomatrix(monk))
friendObject
##explore the features of the CID object using following functions
plot(monk)
n.nodes(friendObject)  ## 71 nodes
is.net.directed(friendObject) ##  This is a directed network
#View(socio(friendObject))
net.density(friendObject)  ##  0.1156  => a denser network than before

##  VISUALIZATION of the network  ##

###  Plotting Sociogram
sociogram.plot(friendObject,main="Friend Network")

###  Plotting Sociomatrix
network.plot(friendObject,main="Friend Network")



##############################################
##  LET'S FIT SOME MODELS
##############################################

##Set the sampling parameters
draws = 100 ##we want 100 draws
thin = 10 ##thinned at every 10 steps
burnin = 5000 ##the first 5000 draws are to be discarded as burnin
#####################################################################


###  Some of these models require very large burnins,
###  so we've fit these models beforehand, and will load
###  them now.
load("SBM-model-fits.RData")


####  Stochastic Block Model:
####    These models require us to specify the number of blocks.
####    For now, let's look at the model with 3 blocks.
mod.SBM.3 <- CID.Gibbs(as.sociomatrix(monk),
                       components=list(SBM(3)),
                       draws=draws,thin=thin,burnin=burnin)
SBM.plot(mod.SBM.3)
SBM.sum <- summary(mod.SBM.3)
SBM.sum
round(pnorm(SBM.sum$SBMcid$block),3)


####  Now, we can plot the observed and fitted sociomatrices:
par(mfrow=c(1,2))
network.plot(mod.SBM.3)
network.plot(mod.SBM.3,fitted=TRUE)

#####  Mixed Membership Stochastic Block Model:
#####    We still must specify the number of blocks.
#####    Here we look at 3 blocks.
mod.MMSBM.3 <- CID.Gibbs(as.sociomatrix(monk),
                         components=list(MMSBM(3)),
                         draws=draws,thin=thin,burnin=burnin)
MMSBM.plot(mod.MMSBM.3)


###  Plotting the Sociomatrix
par(mfrow=c(1,2))
network.plot(mod.MMSBM.3)
network.plot(mod.MMSBM.3,fitted=TRUE)



#####  Latent Space Model:
#####    We specify the dimension of the latent space.
#####    Here we consider 2 dimensions.
mod.LSM <- CID.Gibbs(as.sociomatrix(monk),
                     components=list(LSM(2)),
                     draws=draws,thin=thin,burnin=burnin)
LSM.plot(mod.LSM)

###  Plotting the Sociomatrix
par(mfrow=c(1,2))
network.plot(mod.LSM)
network.plot(mod.LSM,fitted=TRUE)
```

```{r}
###DATA EXPLORATION

###  Let's build a CID object
CID0 <- CID(as.matrix(adj0))

##explore the features of the CID object using following functions
n.nodes(CID0)
is.net.directed(CID0) 
#View(socio(CID0))
net.density(CID0)

##  VISUALIZATION of the network  ##

###  Plotting Sociogram
sociogram.plot(CID0, main="Friend Network")

###  Plotting Sociomatrix
network.plot(CID0,main="Friend Network")

gendercolor2 = as.character(graphFeat[, 78])
gendercolor2 = gsub ("0", "red", gendercolor2)   #specifying  the  colors for  female  (=1)  and male  (=2)
gendercolor2 = gsub ("1", "blue", gendercolor2)

plot.igraph(graph0 , layout = layout.fruchterman.reingold , vertex.color
= gendercolor2 ,
vertex.size = 15, vertex.label.cex = 0.65,  main = "Gender (Red=
F, Blue=M)",
frame = TRUE)

# FAST GREEDY #
kc = fastgreedy.community(graph0)
membership(kc)
plot(kc, graph0)

# LEADING EV #
lev = leading.eigenvector.community(graph0)
lev$membership
membership(lev)

kc = fastgreedy.community(karate) 
membership(kc)
plot(kc, karate)
dendPlot(kc, mode="phylo")



# Validating Partitions #
yeast.gc <- decompose.graph(yeast)[[1]]
func.class <- vertex_attr(yeast.gc, "Class")
table(func.class)
yc <- fastgreedy.community(yeast.gc)
yc
c.m <- membership(yc)
table(c.m, func.class, useNA=c("no"))
```

Clearly the actual number of communities detected in the original
karate network (i.e., three) would be considered unusual from the perspective of
random graphs of fixed size. There is likely an additional mechanism(s) at work, one that goes beyond simply the density and the distribution of social interactions
in this network.
```{r}
nv <- vcount(graph0)
ne <- ecount(graph0)
degs <- degree(adj0)
ntrials <- 1000

# Classical #
num.comm.rg <- numeric(ntrials)
for(i in (1:ntrials)){
  g.rg <- erdos.renyi.game(nv, ne, type="gnm")
  c.rg <- fastgreedy.community(g.rg)
  num.comm.rg[i] <- length(c.rg)
}

rslts <- num.comm.rg
indx <- rep(0, ntrials)
counts <- table(indx, rslts)/ntrials
barplot(counts, beside=TRUE, col=c("blue"),
  xlab="Number of Communities",
  ylab="Relative Frequency",
  legend=c("Fixed Size"))
```
sbm classifiaction
```{r}
setSeed(101)

sbm239 = mixer(as.matrix(adj239), qmin = 1, qmax = 5)
sbm239Output = getModel(sbm239)
sbm239Output$q
sbm239Output$alphas
sbm239Output$Taus[, 1:3]
dim(sbm239Output$Taus)
clusterLabels = c()
for(i in 1:dim(sbm239Output$Taus)[2]){
  clusterLabels[i] = which.max(sbm239Output$Taus[,i])
}

clusterSBM = function(graphK, graphNodesK, adjK, centersK){
  
  #SBM#
  sbmK = mixer(as.matrix(adjK), qmin = 1, qmax = centersK+1)
  sbmKOutput = getModel(sbmK)
  
  clusterLabels = c()
  for(i in 1:dim(sbmKOutput$Taus)[2]){
    clusterLabels[i] = which.max(sbmKOutput$Taus[,i])
  }
  
  graphNodesK$group = clusterLabels
  
  # Checking the clusters #
  clusterID = clusterLabels
  nodesID = graphNodesK$id
  
  clusterList = list()

  for(i in 1:length(unique(clusterID))){
    clusterList[[i]] = graphNodesK$id[which(graphNodesK$group == unique(clusterID)[i])]
  }
  
  circlesKEstK = getCirclesEst(clusterList)
  
  clustKmeans = as_membership(clusterLabels)
  
  communitiesKMeans = make_clusters(graphK, membership = clustKmeans)
  
  plot(communitiesKMeans, graphK)
  plot(sbmK)
  
  return(circlesKEstK)
  
}

sbmEst239 = clusterSBM(graph239, nodes239, adj239, 4)
sbmEst611 = clusterSBM(graph611, nodes611, adj611, 10)


which.max(sbm239Output$Taus[,2])

graph0.sbm.class <- mixer(as.matrix(adj8100), qmin=2, qmax=10, method = "classification")
save(graph0.sbm, file = "SBM0_v2.RData")

graph0.sbm.output = getModel(graph0.sbm)
graph0.sbm.class.output = getModel(graph0.sbm.class)

names(graph0.sbm.output)
names(graph0.sbm.class.output)

graph0.sbm.output$q
graph0.sbm.output$alphas
graph0.sbm.output$Taus[, 1:3]

graph0.sbm.class.output$q
graph0.sbm.class.output$alphas
graph0.sbm.class.output$Taus[,1:10]

plot(graph0.sbm.class)
```
sbm classifiaction
```{r}
graph0.BM = BM_bernoulli("SBM", adj0)
k1 = graph0.BM$estimate()
which.max(graph0.BM$ICL)
graph0.BM$memberships
Z = graph0.BM$memberships[[12]]$Z
plot(graph0.BM$`.->ICL`)
```

```{r}
graph0.leig.fit1 <- eigenmodel_mcmc(adj0, R=2, S=11000, burn=10000)
lat.sp.1 <- eigen(graph0.leig.fit1$ULU_postmean)$vec[, 1:2]
plot(graph0, layout=lat.sp.1,)
plot(graph0)
```



```{r}
##############################################
##  LET'S FIT SOME MODELS
##############################################

##Set the sampling parameters
draws = 100 ##we want 100 draws
thin = 10 ##thinned at every 10 steps
burnin = 5000 ##the first 5000 draws are to be discarded as burnin
#####################################################################
###  Some of these models require very large burnins,
###  so we've fit these models beforehand, and will load
###  them now.
load("SBM-model-fits.RData")

####  Stochastic Block Model:
####    These models require us to specify the number of blocks.
####    For now, let's look at the model with 3 blocks.
graph0.SBM <- CID.Gibbs(CID0,
                       components=list(SBM(5)),
                       draws=draws,thin=thin,burnin=burnin)
SBM.plot(graph0.SBM)
graph0.MMSBM <- CID.Gibbs(CID0,
                         components=list(MMSBM(5)),
                         draws=draws,thin=thin,burnin=burnin)

save(graph0.SBM, file = "A_SBM0.RData")
save(graph0.MMSBM, file = "A_MMSBM0.RData")

load("SBM0.RData")


SBM.sum <- summary(graph0.SBM)
SBM.sum
round(pnorm(SBM.sum$SBMcid$block),3)
names(mod.SBM.3)
length(mod.SBM.3$results)

####  Now, we can plot the observed and fitted sociomatrices:
par(mfrow=c(1,2))
network.plot(graph0.SBM)
network.plot(mod.SBM.3,fitted=TRUE)

#####  Mixed Membership Stochastic Block Model:
#####    We still must specify the number of blocks.
#####    Here we look at 3 blocks.
mod.MMSBM.3 <- CID.Gibbs(as.sociomatrix(monk),
                         components=list(MMSBM(3)),
                         draws=draws,thin=thin,burnin=burnin)
MMSBM.plot(mod.MMSBM.3)


###  Plotting the Sociomatrix
par(mfrow=c(1,2))
network.plot(mod.MMSBM.3)
network.plot(mod.MMSBM.3,fitted=TRUE)



#####  Latent Space Model:
#####    We specify the dimension of the latent space.
#####    Here we consider 2 dimensions.
mod.LSM <- CID.Gibbs(as.sociomatrix(monk),
                     components=list(LSM(2)),
                     draws=draws,thin=thin,burnin=burnin)
LSM.plot(mod.LSM)

###  Plotting the Sociomatrix
par(mfrow=c(1,2))
network.plot(mod.LSM)
network.plot(mod.LSM,fitted=TRUE)
```

```{r}
# Getting it to the correct type #
net239 = graph_from_edgelist(as.matrix(edgeList239), directed = F)

plot(net239)
adj239 = get.adjacency(net239)
adj239 = as.matrix(adj239)
dim(adj239)

coso = (adj0^2)/2

adjExpL = list()
for(i in 1:dim(adj0)[1]){
  adjExpL[[i]] = (adj0^i)/factorial(i)
}
Reduce('+', adjExpL)


adj0 = as.sociomatrix(adj0)
###  Let's build a CID object
ego0 = CID(adj0)
sociogram.plot(ego0)
```

```{r}
##############################################
##  LET'S FIT SOME MODELS
##############################################

##Set the sampling parameters
draws = 100 ##we want 100 draws
thin = 10 ##thinned at every 10 steps
burnin = 5000 ##the first 5000 draws are to be discarded as burnin
#####################################################################

####  Stochastic Block Model:
####    These models require us to specify the number of blocks.
####    For now, let's look at the model with 3 blocks.
mod.SBM.0 <- CID.Gibbs(ego0,
                       components=list(SBM(5)),
                       draws=draws,thin=thin,burnin=burnin)
SBM.plot(mod.SBM.0)

save(mod.SBM.0, file = "K_SBM0.RData")

SBM.sum <- summary(mod.SBM.3)
SBM.sum
round(pnorm(SBM.sum$SBMcid$block),3)
names(mod.SBM.3)
length(mod.SBM.3$results)

####  Now, we can plot the observed and fitted sociomatrices:
par(mfrow=c(1,2))
network.plot(mod.SBM.3)
network.plot(mod.SBM.3,fitted=TRUE)

#####  Mixed Membership Stochastic Block Model:
#####    We still must specify the number of blocks.
#####    Here we look at 3 blocks.
mod.MMSBM.3 <- CID.Gibbs(as.sociomatrix(monk),
                         components=list(MMSBM(3)),
                         draws=draws,thin=thin,burnin=burnin)
MMSBM.plot(mod.MMSBM.3)


###  Plotting the Sociomatrix
par(mfrow=c(1,2))
network.plot(mod.MMSBM.3)
network.plot(mod.MMSBM.3,fitted=TRUE)



#####  Latent Space Model:
#####    We specify the dimension of the latent space.
#####    Here we consider 2 dimensions.
mod.LSM <- CID.Gibbs(as.sociomatrix(monk),
                     components=list(LSM(2)),
                     draws=draws,thin=thin,burnin=burnin)
LSM.plot(mod.LSM)

###  Plotting the Sociomatrix
par(mfrow=c(1,2))
network.plot(mod.LSM)
network.plot(mod.LSM,fitted=TRUE)
```

K-means Clustering:
Found that setting K=10 for people with more than 350 friends and K=6 for fewer than 350 friends worked well for the test data
```{r}
graph.edges <- read.csv(
  file = '0.edges',
  sep=" ", header=F,
  col.names=c("source", "target"))
graph.edges <- graph.edges - min(graph.edges) + 1


nodeList0 <- data.frame(
  id=seq(max(edgeList0) - min(edgeList0) + 1))
nodeList0$group <- 1

network <- forceNetwork(
  Links = edgeList0 - 1, Nodes = nodeList0,
  Source = "source", Target = "target",
  NodeID = "id",
  Group = "group", opacity = 0.8)
network %>% saveNetwork(file = 'Net1.html')
#print(network)

graph.cluster <- function(nodes, edges){
  n <- nrow(graph.nodes)
  adjacency <- matrix(0, n, n)
  index <- cbind(
    graph.edges$source, graph.edges$target)
  adjacency[index] <- 1
  cluster <- mcl(
    x = adjacency, addLoops=TRUE, ESM = TRUE)
  print(cluster$Cluster)
  cluster$Cluster
}

graph.nodes$group <- graph.cluster(
  graph.nodes, graph.edges)

cluster2 = kmeans(adjacency, centers = 20)
graph.nodes$group = cluster2$cluster

network.cluster <- forceNetwork(
  Links = graph.edges - 1, Nodes = graph.nodes,
  Source = "source", Target = "target",
  NodeID = "id",
  Group = "group", opacity = 0.8)
network.cluster %>% saveNetwork(file = 'Net2.html')

print(network.cluster)
```

```{r}
install.packages("RSpectra")
install.packages("biglm")
library(devtools)
install_github("norbertbin/SpecClustPack")
library(SpecClustPack)

data(karate)

k1 = get.adjacency(karate)

#SCVec = specClust(adjMat = as.matrix(k1), nBlocks = 5, nIter = 100)
SCVec239 = specClust(adjMat = adj239, nBlocks = 4, nIter = 1000)


clusterSpec = function(graphK, graphNodesK, adjK, blocksK){
  # Spectral Clustering #
  SCVecK = specClust(adjMat = adjK, nBlocks = blocksK, nIter = 1000)
  #clusterK = kmeans(adjK, centers = centersK)
  graphNodesK$group = SCVecK
  
  # Checking the clusters #
  clusterID = SCVecK
  nodesID = graphNodesK$id
  
  clusterList = list()

  for(i in 1:length(unique(clusterID))){
    clusterList[[i]] = graphNodesK$id[which(graphNodesK$group == unique(clusterID)[i])]
  }
  
  circlesKEstSC = getCirclesEst(clusterList)
  
  clustKSC = as_membership(SCVecK)
  
  communitiesSC = make_clusters(graphK, membership = clustKSC)
  
  plot(communitiesSC, graphK) 
  
  return(circlesKEstSC)
  
}

specEst239 = clusterSpec(graph239, nodes239, adj239, 4)
specEst345 = clusterSpec(graph345, nodes345, adj345, 7)
specEst611 = clusterSpec(graph611, nodes611, adj611, 10)

covProbMat = matrix(c(0.2,0.4,0.1,0.3,0.2,0.4,0.1,0.3,0.2,0.4,0.1,0.3,0.2,0.4,0.1,0.3),
                    nrow=4, byrow = TRUE)
nMembers = c(15,20,45,23)
covMat1 = simBernCovar(covProbMat, nMembers)
covMat1
dim(covMat1)
dim(adj239)

spec2Est239 = casc(adj239, covMat1, nBlocks = 4)

covProbMat = matrix(c(.8, .2, .2, .8), nrow = 2)
nMembers = c(50, 50)
k = simBernCovar(covProbMat, nMembers)

plotAdj(adj239)

library(Matrix)

library(devtools)
install_github("norbertbin/SpecClustPack", force = TRUE)
library(SpecClustPack)

blockPMat = matrix(c(.6,.2,.2,.6), nrow=2)
nMembers = c(5,5)
adjMat = simSBM(blockPMat, nMembers)
clusters = specClust(adjMat, nBlocks = 2)
misClustRate(clusters, nMembers)
estSBM(adjMat, clusters)
covProbMat = matrix(c(.8,.2,.2,.8), nrow=2)
nMembers = c(5,5)
covMat = simBernCovar(covProbMat, nMembers)
casc(adjMat, covMat, nBlocks=2)



levEst239 = levClust(graph239)
levEst345 = levClust(graph345)
levEst611 = levClust(graph611)


```

lda test
```{r}
k = BM_bernoulli("SBM", adj = adj0)
k$estimate()
which.max(k$ICL)
```